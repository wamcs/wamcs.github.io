<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>运输层 | wamcs hood</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="运输层运输层是处于应用层和网络层之间，为运行在不同主机上的应用直接提供通信服务。
运输层概述逻辑通信(logic communication) 是运输层协议为不同主机上的应用进程间提供的功能。通过逻辑通信，运行不同进程的主机仿佛直接俄连接在一起，不需要考虑底层物理传输的细节">
<meta property="og:type" content="article">
<meta property="og:title" content="运输层">
<meta property="og:url" content="wamcs.github.io/2016/04/16/网络/运输层/index.html">
<meta property="og:site_name" content="wamcs hood">
<meta property="og:description" content="运输层运输层是处于应用层和网络层之间，为运行在不同主机上的应用直接提供通信服务。
运输层概述逻辑通信(logic communication) 是运输层协议为不同主机上的应用进程间提供的功能。通过逻辑通信，运行不同进程的主机仿佛直接俄连接在一起，不需要考虑底层物理传输的细节">
<meta property="og:image" content="http://7xt1ey.com1.z0.glb.clouddn.com/UDP-report.png">
<meta property="og:image" content="http://7xt1ey.com1.z0.glb.clouddn.com/UDP-check.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/trsafer_layer_modle.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt1.0.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.0.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.1_sender.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.1_reciver.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.2_sender.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.2_reciver.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt3.0_sender.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/TCP_report.png">
<meta property="og:image" content="http://7xt1ey.com2.z0.glb.clouddn.com/RecevieBuffer.png">
<meta property="og:updated_time" content="2016-09-02T12:29:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="运输层">
<meta name="twitter:description" content="运输层运输层是处于应用层和网络层之间，为运行在不同主机上的应用直接提供通信服务。
运输层概述逻辑通信(logic communication) 是运输层协议为不同主机上的应用进程间提供的功能。通过逻辑通信，运行不同进程的主机仿佛直接俄连接在一起，不需要考虑底层物理传输的细节">
<meta name="twitter:image" content="http://7xt1ey.com1.z0.glb.clouddn.com/UDP-report.png">
  
    <link rel="alternative" href="/atom.xml" title="wamcs hood" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/header_picture.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">wamcs</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Rome was not built in a day</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android-Test/" style="font-size: 10px;">Android Test</a> <a href="/tags/Android-代码记录/" style="font-size: 10px;">Android 代码记录</a> <a href="/tags/Android-基础/" style="font-size: 20px;">Android 基础</a> <a href="/tags/Android-库/" style="font-size: 10px;">Android 库</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/sql语法/" style="font-size: 10px;">sql语法</a> <a href="/tags/数据结构/" style="font-size: 20px;">数据结构</a> <a href="/tags/网络基础/" style="font-size: 15px;">网络基础</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">nothing is true，everything is permitted</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">wamcs</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="/img/header_picture.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">wamcs</h1>
			</hgroup>
			
			<p class="header-subtitle">Rome was not built in a day</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-网络/运输层" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/16/网络/运输层/" class="article-date">
  	<time datetime="2016-04-16T03:53:57.000Z" itemprop="datePublished">2016-04-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      运输层
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络基础/">网络基础</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/网络/">网络</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>运输层是处于应用层和网络层之间，为运行在不同主机上的应用直接提供通信服务。</p>
<h2 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h2><p><strong>逻辑通信(logic communication)</strong> 是运输层协议为不同主机上的应用进程间提供的功能。通过逻辑通信，运行不同进程的主机仿佛直接俄连接在一起，不需要考虑底层物理传输的细节</p>
<a id="more"></a>
<p>运输层协议是在端系统中实现而并非在网络路由器中实现。在发送方运输层将来自应用层的报文转为运输层分组，术语叫做 <strong>运输层报文段(segment)</strong>。然后运输层会将这些报文段传给网络层，网络层再进行封装，包装为网络层分组(数据包)并进行网络间的传输。传输过程中路由器只会关注数据包中网络层字段，对于被封装的运输层报文段是不关心的。这样使得每层的分工明确，并不会越庖代俎。在接收方，网络层将数据包中的运输层报文段取出，向上交给运输层，运输层进行处理，将数据交给应用层。</p>
<h3 id="运输层和网络层关系"><a href="#运输层和网络层关系" class="headerlink" title="运输层和网络层关系"></a>运输层和网络层关系</h3><p>运输层处理的是不同主机间的进程的通信，网络层提供的是主机间的逻辑通信</p>
<p>可以类比信的传输。比如有两个家庭之间进行信件的交流，每家都有多个家庭成员。</p>
<ul>
<li>这些写信的成员 ~ 应用层的不同进程</li>
<li>写的信 ~ 应用层的报文</li>
<li>家庭 ~ 主机。</li>
<li><p>信件收发家庭代理 ~ 运输层协议</p>
<p>每家有一个代理人，每次信件统一交给这个人发送，接收由其分发，这个代理人是在这个家庭中的也就是运输层协议是在端系统中工作的，当然这个运输层协议并不是固定的，可以根据需求来进行选择。</p>
</li>
<li><p>邮政系统 ~ 网络层协议</p>
<p>（数据包是不是很像邮车呢）和现实中一样，代理人提供的信件服务是受到邮政系统的限制的，如果网络层不能为主机间的运输层报文段提供时延和带宽保证，那么同样运输层不能为两进程间的报文传输提供保证的。</p>
</li>
</ul>
<h3 id="Internet中的运输层"><a href="#Internet中的运输层" class="headerlink" title="Internet中的运输层"></a>Internet中的运输层</h3><p>一般的网络是TCP/IP网络，为应用层提供了两种不同的运输层协议<u>TCP和UDP</u>。特点不同有不同的使用情景。</p>
<p>UDP和TCP的最基本任务是将两端系统间的交付服务拓展到运行在两个端系统的进程间的交付服务。这期间所做的分别称为 <strong>运输层间的多路复用(transport-layer-multiplexting)</strong>，<strong>多路分解(demultiplexting)</strong>。UDP和TCP还可以通过在报文段的首部中添加检测字段而提供完整性检查。<br>进程间数据交付和差错检测是两种最低限度的运输层服务。</p>
<p>UDP只实现了上述两种功能，相比之下TCP还提供 <strong>可靠数据传输(reliable data transfer)</strong>，<strong>拥塞控制(congestion control)</strong></p>
<h2 id="多路复用-amp-多路分解"><a href="#多路复用-amp-多路分解" class="headerlink" title="多路复用&amp;多路分解"></a>多路复用&amp;多路分解</h2><p>socket是进程和网络间进行数据交流的渠道，每一个进程有一个或者是多个socket。运输层在对应用层进行数据交付时，实际上是通过socket做为代理进行的（看看应用层中关于socket的使用就明白了）</p>
<p>由于在任何时刻同一主机上可能会有多个socket同时存在，为了进行准确的数据传输，对每个socket有唯一的标识符，格式取决于是TCP还是UDP</p>
<h3 id="定义解释"><a href="#定义解释" class="headerlink" title="定义解释"></a>定义解释</h3><ul>
<li><strong>多路分解</strong>:接收端，运输层通过报文段中的标识字段标识出接收socket，然后将报文分发给对应的socket</li>
<li><strong>多路复用</strong>：从源主机不同的socket收集数据块。并为数据块封装（加首部）生成报文，然后分发</li>
</ul>
<h3 id="socket标识"><a href="#socket标识" class="headerlink" title="socket标识"></a>socket标识</h3><p>多路复用和多路分解对于socket的标识提出了要求</p>
<ul>
<li>socket有唯一标识符</li>
<li>每个报文段中有特殊字段来指示该报文段所要交付的socket</li>
</ul>
<p>标识符使用的是端口，而特殊的字符段是 <strong>源端口号字段(source port number field)</strong> 和 <strong>目的端口号字段(destination port number field)</strong> 。端口号是一个16byte的数字大小在0~65535间，其中0~1023叫做 <strong>周知端口号(well-know port number)</strong>，是保留给HTTP，FTP等应用层协议使用的。</p>
<h3 id="服务分析"><a href="#服务分析" class="headerlink" title="服务分析"></a>服务分析</h3><h4 id="1-无连接的多路复用和多路分解"><a href="#1-无连接的多路复用和多路分解" class="headerlink" title="1.无连接的多路复用和多路分解"></a>1.无连接的多路复用和多路分解</h4><p>对于UDP来说，在java中用如下代码创建一个socket<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DatagramSocket mySocket = <span class="keyword">new</span> DatagramSocket();</div></pre></td></tr></table></figure></p>
<p>这种方法创建时，运输层自动为该socket分配一个端口号（1024~65535）。当然也可以指定端口号<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DatagramSocket mySocket = <span class="keyword">new</span> DatagramSocket(<span class="number">19157</span>);</div></pre></td></tr></table></figure></p>
<p>一般来说是为Server设定固定端口，Client随机分配<br><br><br></p>
<p>现有主机A的进程有UDP端口号为19157，主机B的进程UDP端口号46428。发送的时候，主机A中的运输层创建报文段，包括应用层数据，源端口号（19157），目标端口号（46428），UDP长度，UDP检验和。然后将报文段交给网络层。网络层将其封装到一个IP数据报中，并尽力将其交给主机B。主机B的运输层会坚持报文段的目的端口号并传给该端口号的socket。</p>
<p><strong>ps：</strong></p>
<ul>
<li>如果两个UDP报文段源IP/源端口不同，但是目的端口和目的IP相同，那么会经过同一个socket传入到同一个进程中</li>
<li>一个UDP的socket是有一个包含目的IP地址和目标端口号的二元组定义。任何一个socket在这样定义后都可以定位到。</li>
<li>源端口号的作用是当server想反过来作为发送端，这时源端口号就变成目的端口号可以来发送了</li>
</ul>
<h4 id="2-面向连接的多路复用和多路分解"><a href="#2-面向连接的多路复用和多路分解" class="headerlink" title="2.面向连接的多路复用和多路分解"></a>2.面向连接的多路复用和多路分解</h4><p>TCP的socket和UDP的socket的区别在于TCP的socket是由一个四元组构成的(源端口，目的端口，源IP，目的IP)，与UDP的区别是如果两个报文段源IP/源端口不同，但是目的端口和目的IP相同，那么仍会用不同的socket传递</p>
<h4 id="3-web服务器与TCP"><a href="#3-web服务器与TCP" class="headerlink" title="3.web服务器与TCP"></a>3.web服务器与TCP</h4><p>web服务器有着固定的端口80，所有的报文段中目的端口都是80，而web服务器通过源IP和源端口来进行区分</p>
<p>特别的是web服务器通常只是用一个进程，但是为每个新的客户机连接创建一个具有新连接socket的新线程。为了保证性能客户机和服务器采取的是Http持久连接</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP被称为无连接的，这是因为UDP本身是极其简单的运输协议，在网络层的IP协议上除了增加多路复用/多路分解和差错检验外，什么都没做，这就是说UDP只负责了运输层数据的分发收集，看看数据有没有差错，在发送报文前并没有握手的阶段。数据发出去谁接到都不关心，也就是为什么称其为无连接的。</p>
<p>UDP的某些特性使得虽然其无连接，不可靠，但是在某些情景十分有用</p>
<ul>
<li><strong>应用层能够更好得控制要发送的数据和时间</strong>。采用UDP时，只要应用进程将数据传给UDP，UDP就会立刻打包传给网络层。而TCP拥有拥塞机制，在到目的主机间的链路拥挤时会抑制发送方发送报文，而且TCP需要接收方确认数据的完整收到，不管时间多长。显然对于一些即时性的情景，比如视频播放，音乐播放等，需要快速传递信息，允许丢失数据就非常有用了</li>
<li><strong>无需建立连接</strong> TCP在连接之前需要三次握手，而UDP直接就可以传数据。UDP没有建立连接的时延。可能是DNS运行在UDP上的主要原因</li>
<li><strong>无连接状态</strong> TCP需要在端系统维护连接状态，包括接收发送缓存，拥塞控制参数，序号和确认号参数。UDP就没这么麻烦了</li>
<li><strong>分组首部开销小</strong> 每个TCP报文段都有20字节的首部开销，而UDP只有8字节</li>
</ul>
<p>虽说UDP用于流式媒体，然而毕竟UDP没有拥塞机制，当网络处于拥塞状态时，UDP是不会停止数据发送的，只会使得路由器大量分组溢出，几乎没有UDP分组能够成功传输。而且如果有TCP存在的话，无控制的UDP带来的高丢包率会减小TCP发送方的速率。这是UDP一个潜在的严重问题</p>
<h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><p><img src="http://7xt1ey.com1.z0.glb.clouddn.com/UDP-report.png" alt=""></p>
<ul>
<li>源端口号：2字节<br>-目的端口号：2字节</li>
<li>UDP长度：长度2个字节，指明是UDP首部和UDP数据的字节长度；该字段的最小值为8字节（发送一份0字节的UDP数据包是OK的）</li>
<li>UDP检验和：覆盖UDP首部和UDP数据。UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地。</li>
</ul>
<h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p><img src="http://7xt1ey.com1.z0.glb.clouddn.com/UDP-check.png" alt=""></p>
<ol>
<li>首先将检验和部分添零；</li>
<li>然后将UDP伪首部部分，UDP首部部分，数据部分都划分成16位的一个个二进制数；</li>
<li>将这些数逐个相加，记得溢出的部分加到最低位上，这是循环加法：</li>
<li>最后将得到的结果取反，则可以得到检验和位</li>
</ol>
<p>接收方重新加一次然后和检验和相加，全为1则没有损失，否则就丢弃</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="可靠性通信协议"><a href="#可靠性通信协议" class="headerlink" title="可靠性通信协议"></a>可靠性通信协议</h3><p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/trsafer_layer_modle.png" alt=""></p>
<p>以下是通信协议发展的思路</p>
<h4 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h4><p>最简单的情况提供稳定可靠的信息通路,只需传输接收就好</p>
<p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt1.0.png" alt=""></p>
<h4 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h4><p>在底层信道模型中分组的比特可能受损，为了保证数据完全接收，需要接收方对发送方进行一次确认。成功接收发送肯定确认，接收失败发送否定确认。接收到否定确认时会进行重传，这里重传采用的是 <strong>自动重传机制协议（Automatic Repeat reQuest，ARQ）</strong>。ARQ中采用别的三种协议来处理比特差错,<strong>差错检测，接收方反馈，重传</strong></p>
<p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.0.png" alt=""></p>
<h4 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h4><p>我们没有考虑到的是包含确认信息的报文丢失或受损怎么处理</p>
<ul>
<li>第一种可能，发送方接收到破损的确认信息，再向接收方发送确认报文请求确认，但这样并没有解决实际问题，在最坏的情况下，双方会一直不停的确认</li>
<li>第二种可能，增加足够的检验和，使得发送方不仅可以检验比特差错，还可以恢复比特差错，但对于丢失分组的情况就无法起作用了</li>
<li>第三种可能，接收到模糊不清的ACK或NAK分组，就重新发送分组。这里引进了冗余分组，接收方并不知道现在接收到的是新的还是一次重传</li>
</ul>
<p>解决第三种问题的简单方法，也是几乎现存所有运输协议都在使用的，就是在数据分组中加入新字段，对数据进行分组编号，接收方只需检测序号就知道是否为重传</p>
<p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.1_sender.png" alt=""></p>
<p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.1_reciver.png" alt=""></p>
<h4 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h4><p>2.2与2.1的区别在于在ACK，NAK报文中中加入了分组序号，发送方需要检查接收到的ACK，NAK报文中的分组序号</p>
<p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.2_sender.png" alt=""></p>
<p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt2.2_reciver.png" alt=""></p>
<h4 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h4><p>rdt3.0是 <strong>具有比特差错的丢包信道上的可靠数据传输</strong> 。在当今的网络中丢包是非常常见的，该协议解决了两个问题：<strong>如何检测丢包</strong> 和 <strong>丢包之后该怎么办</strong> 。利用rdt2.2中的采取的技术，如检验和，序号，ACK分组和重传等可以解决丢包之后的处理问题。现在需要处理的是如何检测到丢包，这个协议中让发送方来进行检测和恢复丢包。假定发送方发送一个分组，丢包的可能有两种，一种是该分组丢失，另一种是回应该分组的ACK报文丢失。发送方只需要等待足够长的时间就可以确认已经发生丢包。这个时间最少是一个发送方和接收方的往返时延，然而在实际中往返时延非常难于估计，发送方可能会一直等待，这显然是不合理的。所以可以人为地设置一个阈值，超出这个阈值就重新发送。这在发送方和接收方的信道中引入了 <strong>冗余数据分组(duplicate data packer)</strong>.然而在rdt2.2中采用的分组序号可以很好得解决这个问题</p>
<p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/transfer_layer_rdt3.0_sender.png" alt=""></p>
<p>图中给出的有限状态机中我们可以看到有start_timer和stop_timer的调用。在协议中为了实现基于时间的重传机制，需要一个countdown timer<br>在指定时间过后，中断发送方当前的状态，采取对应的响应动作</p>
<p>rdt说到这其实还有没结束，rdt3.0直接使用的后果是效率太低，所以需要修正协议来提高效率，具体细节可以参考《计算机网络自定向下》.4th运输层关于这一部分的详细解释</p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP连接不同于UDP连接，TCP连接有三次握手的过程，是点对点的连接，而且连接时双工的。</p>
<p>TCP的三次握手</p>
<ul>
<li>客户机首先发送一段TCP报文给服务机，请求进行连接</li>
<li>服务机接收到后回应客户机，给客户机发送另一个特殊的TCP报文，授予连接</li>
<li>客户机再用第三个特殊的TCP报文作为响应，确认已连接</li>
</ul>
<p>应用层的数据通过socket后，会由传输层中的TCP控制，TCP将这些数据引导到该连接的 <strong>发送缓存(send buffer)</strong> 中,发送缓存是在三次握手初期建立的缓存。接下来TCP会不时地从发送缓存中取出数据进行发送。</p>
<p>TCP从缓存中取出并放入报文段中的数据的量受限于 <strong>最大报文长度(maximum segment size, MSS)</strong>。MSS通常由最初确定的最大链路层帧长度来设置，即 <strong>最大传输单元(maximum transmission unit, MTU)</strong>。MTU常见值为1460字节、536字节或512字节。</p>
<p>TCP将每块客户机数据加上一个TCP首部，形成一个TCP报文，交给网络层发送。网络层将其分装到网络层IP数据报文中。当TCP在另一端接收到报文后，会将其放入该段中的接收缓存中，应用层从接收缓存中获取数据。</p>
<h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/TCP_report.png" alt=""></p>
<p>和UDP一样首部有源端口号和目的端口号，检验和字段。还有下列字段：</p>
<ul>
<li>32byte序号字段和32byte确认号字段</li>
<li>16byte接收窗口字段，用于流量控制</li>
<li>4byte首部长度字段，指示了TCP首部长度，由于TCP选项字段的存在，TCP首部长度是可变的</li>
<li>6byte的标志字段，共有6种flag。ACK用于确认报文被成功接收；RST，SYN，FIN用于连接的建立和拆除；PSH指示接收方立即将数据交给上层。URG表示报文段中存着被发送方上层实体置为“紧 急”的数据。紧急数据的最后一个字节由16byte的紧急数据指针指出。PSH，URG在实际中并不会用到。</li>
</ul>
<p><strong>对于序号和确认号的说明</strong><br><br>TCP的报文序号是建立在传送的字节流上的，而不是传送的报文段的顺序上的。比如进程A向进程B发送一个数据流，该数据流由一个包含500000字节的文件组成，MSS为1000字节，数据流首字节的编号为0。第一个报文段的序号为0，第二个报文段的序号为1000，第三个为2000……<br><br>确认号指的是第一个丢失字节的序号，是希望得到的字节。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>在TCP报文中可以看到有一行首部为接收窗口字段，这行是用来进行流量控制的。</p>
<p>有这个机制的原因是接收方的应用忙于别的任务，获取数据相当缓慢，而发送方发送的数据过多，过快，会导致连接的接收缓存溢出。所以需要遏制发送方的发送速率。和拥塞机制的差异在于拥塞机制是用来处理网络拥塞的情况的。</p>
<p>TCP让发送方维护着一个称为 <strong>接收窗口(receive window)</strong> 的变量来提供流量控制。</p>
<p>现假设主机A通过一条连接连向主机B发送一个大文件。主机B会为该连接分配一个接收缓存，用RcvBuffer来表示其大小。定义如下变量：</p>
<ul>
<li>LastByteRead：主机B上的应用进程从缓存中读出的数据流的最后一个字节的编号</li>
<li>LastByteRcvd：从网络中到达的并且已经放入主机B接收缓存中的数据流最后一个字节的编号</li>
</ul>
<p>TCP不允许缓存溢出,所以有式成立：LastByteRcvd - LastByteRead &lt;= RcvBuffer</p>
<p>接收窗口用RcvWindow表示：RcvWindow=RcvBuffer-[LastByteRcvd-LastByteRead]</p>
<p><img src="http://7xt1ey.com2.z0.glb.clouddn.com/RecevieBuffer.png" alt=""></p>
<p>主机B通过把当前的RcvWindow值放入发给主机A的报文段接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间</p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP连接</p>
<ul>
<li>第一步：客户机向服务其器发送一个特殊的TCP报文，该报文中不包含应用层数据，其首部行中的SYN标志位被设为1。也被称为SYN报文</li>
<li>第二步：服务器接收到SYN报文，为该TCP连接分配发送缓存和接收缓存，并向客户机发送允许连接的报文。SYN比特被设为1，初始化确认号和序号，该报文段也被称为SYNACK报文段</li>
<li>第三步：接收到SYNACK报文后客户机也要为连接分配缓存，客户机还会向服务器发送另一个报文段，这个报文段对服务器的允许连接的报文段进行了确认，SYN被设为0</li>
</ul>
<p>TCP断开</p>
<ul>
<li>第一步：客户机向服务器发送FIN比特为1的TCP报文</li>
<li>第二步：服务器接收到报文，向客户机发送一个确认报文段</li>
<li>第三步：客户机发送终止报文段，FIN为1</li>
<li>第四步：服务器发送确认报文</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/02/android/View事件体系/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          View事件体系
        
      </div>
    </a>
  
  
    <a href="/2016/04/10/android/AIDL-下/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">AIDL(下)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="网络/运输层" data-title="运输层" data-url="wamcs.github.io/2016/04/16/网络/运输层/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 wamcs
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: undefined,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>